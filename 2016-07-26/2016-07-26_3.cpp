// 연산자 오버로딩을 하는 이유

// 1) 객체를 기본 타입처럼 사용하기 위해
// num = 10 + 10;

//	class time
//	{
//	private:
//		int h;
//		int m;
//		int s;
//	};
//	time t1(3,10,20);
//	time t2(2,10,30);
//	t1 + t2;

// 2) 함수 호출보다 간단한 기호를 통해서 사용하기 위해

//	class time
//	{
//	private:
//		int h;
//		int m;
//		int s;
//	public :
//		void add(time &t)
//		{
//		...
//		}
//	};
//	t1.add(t2)
//	t1 + t2;

// 연산자 오버로딩이 불가능한 연산자

// . (멤버 접근)
// .* (멤버 포인터)
// :: (스코프 연산자)
// ? : (3항 연산자)
// sizeof
// static_cast (캐스팅 연산자)

// 연산자 오버로딩의 종류

// 1) 멤버 함수로 구현	ex) cout
// 2) 전역 함수로 구현

// + 를 멤버 함수로 구현
// 멤버 함수 : a.operator+(b)
// 전역 함수 : operator+(a,b)

// 멤버 함수로만 오버로딩이 가능한 연산자
// = (대입 연산자)
// () (소괄호 연산자)
// [] (대괄호 연산자)
// ->

// 연산자 오버로딩 주의 사항

// 1) 본래 연산자의 의미를 홰손하지 말 것
// t1 + t2;	 시간을 더하다
// 2) 연산자 오버로딩을 하더라도, 우선 순위와 결합 순서는 동일
// 3) 연산자 함수 : 디폴트 파라미터를 지정할 수 없다